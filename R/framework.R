#' Generate time series data based on different generators
#'
#' This function will construct a portfolio of asset returns based on the time
#' range specified or the number of 'observations' requested. The resulting time
#' series will be based on the specified calendar, as defined by trading_dates
#' that uses the timeDate package under the hood.
#'
#' @section Usage:
#' rprices(process, start=Sys.Date(), ohlc=FALSE, volume=FALSE, ...)
#'
#' @section Details:
#' The main entry point is getPortfolioPrices, which generates a TxM xts object 
#' based on the symbols provided. Prices generated by this function can be used
#' in risk modeling, as a substitute for brownian motion in Monte Carlo
#' simulations, and backtesting applications. Studying fractal generation of
#' time series can be accomplished more directly by calling 
#' \code{\link{rfractal}}.
#'
#' In addition to the arguments above, it is necessary to pass the appropriate
#' arguments to the the underlying fractal call. This includes passing in a seed
#' and generator patterns. If none are provided predefined sets will be used,
#' although users of this package are encouraged to create their own initiators
#' and generators.
#'
#' The trading_dates function is a utility to generate proper business days for
#' a given calendar. This is used to be compatible with other applications that
#' load actual asset data.
#'
#' @name rprices
#' @param process The process to use
#' @param start Start date
#' @param ohlc Whether to include OHLC values
#' @param volume Whether to include volume
#' @param \dots Additional arguments to date generator
#' @return An xts object with either obs rows or points in the range 
#' [start,end] and a time series for each symbol provided.
#'
#' @examples
#' mygbm <- function(x) gbm(x, 40, .03/1440)
#' ps <- rprices(mygbm, obs=100)
rprices(process, start, ohlc, volume, ...) %::% Function:.:logical:logical:...:xts
rprices(process, start=Sys.Date(), ohlc=FALSE, volume=FALSE, ...) %as% {
  dates <- trading_dates(start=start, ...)
  n <- length(dates)
  prices <- as.xts(process(n), order.by=dates)
  #rownames(prices) <- format(dates)
  colnames(prices) <- 'close'

  if (ohlc) prices <- .add_ohlc(prices, ohlc)
  if (volume) prices <- .add_volume(prices, volume)
  prices
}


# beta_a = cov(r_a, r_m) / var(r_m)
# cov(r_a, r_m) = beta_a * var(r_m)
# cor(r_a, r_m) = cov(r_a, r_m) / (sd(r_a) * sd(r_m))
# Generate a random vector based on a time period and betas
rprices(beta, var=252) %as% {
  n <- 1 + length(beta)
  m <- matrix(rep(0,n^2), nrow=n)
  m[1,] <- c(1, beta)
  m[,1] <- c(1, beta)
  diag(m) <- 1
  cor.mat <- denoise(m, RandomMatrixDenoiser())
  cd <- chol(cor.mat)
  z <- matrix(rnorm(length(m)), nrow=nrow(m))
  v <- t(cd) %*% z
}

# m <- rprices(c(.5,.8,.3,-.3,1.4))
# md <- denoise(m, RandomMatrixDenoiser())
# cd <- chol(md)
# z <- matrix(rnorm(length(m)), nrow=nrow(m))
# v <- t(cd) %*% z



#' Generate trading dates with a given calendar
#'
#' @name trading_dates
#' @param period The date period, defaulting to 1 day (1440 minutes).
#' Units are in minutes, so values less than 1440 will result in 
#' intraday time steps being added.
#'
#' @examples
#' trading_dates('2009-02-24',obs=10)
#'
#' th <- function(x) trading_hours(x,'cme')
#' trading_dates('2014-01-01','2014-03-31', 5, th)
trading_dates(start, end, calendar=holidayNYSE) %::% a:a:Function:Date
trading_dates(start, end, calendar=holidayNYSE) %as% {
  start <- as.Date(start)
  end <- as.Date(end)
  dates <- timeSequence(from=start, to=end)
  dates <- dates[isBizday(dates, holidays=calendar(unique(year(dates))))]
  as.Date(dates)
}

trading_dates(start, obs, calendar=holidayNYSE) %::% a:numeric:Function:.
trading_dates(start, obs, calendar=holidayNYSE) %when% { obs==0 } %as% {
  # returning NULL, not NA
  NULL
}

trading_dates(start, obs, calendar=holidayNYSE) %::% a:numeric:Function:Date
trading_dates(start, obs, calendar=holidayNYSE) %when% { obs>0 } %as% {
  start <- as.Date(start)
  # if use other numbers here, 
  # make sure step.size * max.its can always cover obs trading days
  step.size <- 50
  # cannot use infinity here, memory will blow up
  max.its <- ceiling(obs/step.size)*2
  holidays_save <- list()
  dates <- callCC(function(ext) fold(1:max.its, function(i, dates){
      if (length(dates) >= obs) ext(dates[1:obs])
      # not using ifelse function, cuz it will coerce Date into integer
      from_date <- start
      if(!is.null(dates))  from_date <- dates[length(dates)]+1
      step <- timeSequence(from=from_date, length.out=step.size)
      ys <- unique(year(step))
      sapply(ys, function(y) {
       if(is.null(holidays_save[[as.character(y)]])) {
         holidays_save[[as.character(y)]] <<- calendar(y)
       }
      })
      holidays <- fold(ys[2:length(ys)], function(y, holidays) {
        holidays <- c(holidays, holidays_save[[as.character(y)]])
      }, holidays_save[[as.character(ys[1])]])

      inc <- as.Date(step[isBizday(step, holidays=holidays)])
      # c(NULL, inc) will coerce Date into integer, so judge the conditions
      if(is.null(dates)) { return(inc)
      } else return(c(dates, inc))
    }, NULL))
  dates
}

trading_dates(start, obs, calendar=holidayNYSE) %when% { obs<0 }  %as% {
  obs <- -obs
  start <- as.Date(start)
  # if use other numbers here, 
  # make sure step.size * max.its can always cover obs trading days
  step.size <- 50
  # cannot use infinity here, memory will blow up
  max.its <- ceiling(obs/step.size)*2
  holidays_save <- list()
  dates <- callCC(function(ext) fold(1:max.its, function(i, dates){
      if (length(dates) >= obs) ext(tail(dates, obs))
      # not using ifelse function, cuz it will coerce Date into integer
      from_date <- start
      if(!is.null(dates))  from_date <- dates[1] - 1
      step <- timeSequence(from = from_date - step.size + 1, length.out = step.size)
      ys <- unique(year(step))
      sapply(ys, function(y) {
       if(is.null(holidays_save[[as.character(y)]])) {
         holidays_save[[as.character(y)]] <<- calendar(y)
       }
      })
      holidays <- fold(ys[2:length(ys)], function(y, holidays) {
        holidays <- c(holidays, holidays_save[[as.character(y)]])
      }, holidays_save[[as.character(ys[1])]])

      inc <- as.Date(step[isBizday(step, holidays=holidays)])
      # same as above. c(inc, NULL) will coerce Date into integer
      if(is.null(dates)) { return(inc)
      } else return(c(inc, dates))
    }, NULL))
  dates
}


trading_dates(start, obs, period, hours.fn) %::% a:numeric:numeric:Function:POSIXt
trading_dates(start, obs, period=1, hours.fn) %as% {
  dates <- trading_dates(start, obs)
  hours <- hours.fn(dates)
  ts <- lapply(dates, 
    function(d) as.POSIXct(d) + intraday_ticks(period, hours[d]))
  unique(do.call(c, ts))
}

# For intraday times
trading_dates(start, end, period, hours.fn) %::% a:a:numeric:Function:POSIXt
trading_dates(start, end, period=1, hours.fn) %as% {
  dates <- trading_dates(start, end)
  hours <- hours.fn(dates)
  ts <- lapply(dates, 
    function(d) as.POSIXct(d) + intraday_ticks(period, hours[d]))
  unique(do.call(c, ts))
}



#' Plot asset prices and returns for fractal analysis 
#'
#' This is a convenience function for studying the generated time series by the
#' fragtalrock package. Given a time series of prices, plotReturns will plot
#' both the original time series of prices and the returns series. This is a
#' useful visual aid in determining the utility of the simulated time series.
#'
#' @param series A time series 
#' @param \dots Additional arguments to pass to plot
plot_returns <- function(series, ...)
{
  ret <- series[-1] / series[-length(series)] - 1
  o.par <- par(mfrow=c(2,1), mar=c(3.1, 2.1, 2.1, 1.1))
  plot(series, type='l', main='Prices',...)
  plot(ret, main='Returns')
  par(o.par)
  invisible(series)
}

